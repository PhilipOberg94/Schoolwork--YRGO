
HWprogrammering07.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  000001dc  00000270  2**0
                  ALLOC, LOAD, DATA
  1 .text         000000c4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      0000002f  00000000  00000000  00000270  2**0
                  CONTENTS, READONLY
  3 .stack.descriptors.hdr 0000000e  00000000  00000000  0000029f  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000038  00000000  00000000  000002ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000a0e  00000000  00000000  000002e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000006b3  00000000  00000000  00000cf3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000002aa  00000000  00000000  000013a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000078  00000000  00000000  00001650  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000208  00000000  00000000  000016c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000001b5  00000000  00000000  000018d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000028  00000000  00000000  00001a85  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000004  000001c4  000001c4  00000258  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001ab0  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.swap    00000012  000001b2  000001b2  00000246  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.selectionSort 00000062  000000c4  000000c4  00000158  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.writearray 00000018  00000184  00000184  00000218  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .rodata       0000000a  00800100  000001d2  00000266  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 18 .text.main    0000005e  00000126  00000126  000001ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.__dummy_fini 00000002  000001cc  000001cc  00000260  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.__dummy_funcs_on_exit 00000002  000001ce  000001ce  00000262  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.__dummy_simulator_exit 00000002  000001d0  000001d0  00000264  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.exit    00000016  0000019c  0000019c  00000230  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text._Exit   00000004  000001c8  000001c8  0000025c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 38 00 	jmp	0x70	; 0x70 <__ctors_end>
   4:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
   8:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
   c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  10:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  14:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  18:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  1c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  20:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  24:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  28:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  2c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  30:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  34:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  38:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  3c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  40:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  44:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  48:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  4c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  50:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  54:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  58:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  5c:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  60:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>
  64:	0c 94 e2 00 	jmp	0x1c4	; 0x1c4 <__bad_interrupt>

00000068 <.dinit>:
  68:	01 00       	.word	0x0001	; ????
  6a:	01 0a       	sbc	r0, r17
  6c:	00 01       	movw	r0, r0
  6e:	d2 00       	.word	0x00d2	; ????

00000070 <__ctors_end>:
  70:	11 24       	eor	r1, r1
  72:	1f be       	out	0x3f, r1	; 63
  74:	cf ef       	ldi	r28, 0xFF	; 255
  76:	d8 e0       	ldi	r29, 0x08	; 8
  78:	de bf       	out	0x3e, r29	; 62
  7a:	cd bf       	out	0x3d, r28	; 61

0000007c <__do_copy_data>:
  7c:	e8 e6       	ldi	r30, 0x68	; 104
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	40 e0       	ldi	r20, 0x00	; 0
  82:	17 c0       	rjmp	.+46     	; 0xb2 <__do_clear_bss+0x8>
  84:	b5 91       	lpm	r27, Z+
  86:	a5 91       	lpm	r26, Z+
  88:	35 91       	lpm	r19, Z+
  8a:	25 91       	lpm	r18, Z+
  8c:	05 91       	lpm	r16, Z+
  8e:	07 fd       	sbrc	r16, 7
  90:	0c c0       	rjmp	.+24     	; 0xaa <__do_clear_bss>
  92:	95 91       	lpm	r25, Z+
  94:	85 91       	lpm	r24, Z+
  96:	ef 01       	movw	r28, r30
  98:	f9 2f       	mov	r31, r25
  9a:	e8 2f       	mov	r30, r24
  9c:	05 90       	lpm	r0, Z+
  9e:	0d 92       	st	X+, r0
  a0:	a2 17       	cp	r26, r18
  a2:	b3 07       	cpc	r27, r19
  a4:	d9 f7       	brne	.-10     	; 0x9c <__do_copy_data+0x20>
  a6:	fe 01       	movw	r30, r28
  a8:	04 c0       	rjmp	.+8      	; 0xb2 <__do_clear_bss+0x8>

000000aa <__do_clear_bss>:
  aa:	1d 92       	st	X+, r1
  ac:	a2 17       	cp	r26, r18
  ae:	b3 07       	cpc	r27, r19
  b0:	e1 f7       	brne	.-8      	; 0xaa <__do_clear_bss>
  b2:	ef 36       	cpi	r30, 0x6F	; 111
  b4:	f4 07       	cpc	r31, r20
  b6:	31 f7       	brne	.-52     	; 0x84 <__do_copy_data+0x8>
  b8:	0e 94 93 00 	call	0x126	; 0x126 <main>
  bc:	0c 94 ce 00 	jmp	0x19c	; 0x19c <exit>

000000c0 <_exit>:
  c0:	f8 94       	cli

000000c2 <__stop_program>:
  c2:	ff cf       	rjmp	.-2      	; 0xc2 <__stop_program>

Disassembly of section .text:

000001c4 <__bad_interrupt>:
 1c4:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.swap:

000001b2 <swap>:
#include <stdint.h>


void swap(uint8_t* xp, uint8_t* yp) 
{ 
    uint8_t temp = *xp; 
 1b2:	fc 01       	movw	r30, r24
 1b4:	20 81       	ld	r18, Z
    *xp = *yp; 
 1b6:	fb 01       	movw	r30, r22
 1b8:	30 81       	ld	r19, Z
 1ba:	fc 01       	movw	r30, r24
 1bc:	30 83       	st	Z, r19

    *yp = temp; 
 1be:	fb 01       	movw	r30, r22
 1c0:	20 83       	st	Z, r18
 1c2:	08 95       	ret

Disassembly of section .text.selectionSort:

000000c4 <selectionSort>:
} 
  
// Function to perform Selection Sort 
void selectionSort(uint8_t arr[], uint8_t n) 
{ 
  c4:	0f 93       	push	r16
  c6:	1f 93       	push	r17
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
  cc:	ec 01       	movw	r28, r24
  ce:	16 2f       	mov	r17, r22
    uint8_t i, j, min_idx; 
  
    // One by one move boundary of 
    // unsorted subarray 
    for (i = 0; i < n - 1; i++) { 
  d0:	40 e0       	ldi	r20, 0x00	; 0
  d2:	1c c0       	rjmp	.+56     	; 0x10c <selectionSort+0x48>
        // Find the minimum element in 
        // unsorted array 
        min_idx = i; 
        for (j = i + 1; j < n; j++) 
  d4:	01 e0       	ldi	r16, 0x01	; 1
  d6:	04 0f       	add	r16, r20
    // One by one move boundary of 
    // unsorted subarray 
    for (i = 0; i < n - 1; i++) { 
        // Find the minimum element in 
        // unsorted array 
        min_idx = i; 
  d8:	34 2f       	mov	r19, r20
        for (j = i + 1; j < n; j++) 
  da:	80 2f       	mov	r24, r16
  dc:	0c c0       	rjmp	.+24     	; 0xf6 <selectionSort+0x32>
            if (arr[j] < arr[min_idx]) 
  de:	fe 01       	movw	r30, r28
  e0:	e8 0f       	add	r30, r24
  e2:	f1 1d       	adc	r31, r1
  e4:	20 81       	ld	r18, Z
  e6:	fe 01       	movw	r30, r28
  e8:	e3 0f       	add	r30, r19
  ea:	f1 1d       	adc	r31, r1
  ec:	90 81       	ld	r25, Z
  ee:	29 17       	cp	r18, r25
  f0:	08 f4       	brcc	.+2      	; 0xf4 <selectionSort+0x30>
                min_idx = j; 
  f2:	38 2f       	mov	r19, r24
    // unsorted subarray 
    for (i = 0; i < n - 1; i++) { 
        // Find the minimum element in 
        // unsorted array 
        min_idx = i; 
        for (j = i + 1; j < n; j++) 
  f4:	8f 5f       	subi	r24, 0xFF	; 255
  f6:	81 17       	cp	r24, r17
  f8:	90 f3       	brcs	.-28     	; 0xde <selectionSort+0x1a>
            if (arr[j] < arr[min_idx]) 
                min_idx = j; 
  
        // Swap the found minimum element 
        // with the first element 
        swap(&arr[min_idx], &arr[i]); 
  fa:	be 01       	movw	r22, r28
  fc:	64 0f       	add	r22, r20
  fe:	71 1d       	adc	r23, r1
 100:	ce 01       	movw	r24, r28
 102:	83 0f       	add	r24, r19
 104:	91 1d       	adc	r25, r1
 106:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <swap>
{ 
    uint8_t i, j, min_idx; 
  
    // One by one move boundary of 
    // unsorted subarray 
    for (i = 0; i < n - 1; i++) { 
 10a:	40 2f       	mov	r20, r16
 10c:	24 2f       	mov	r18, r20
 10e:	30 e0       	ldi	r19, 0x00	; 0
 110:	81 2f       	mov	r24, r17
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	01 97       	sbiw	r24, 0x01	; 1
 116:	28 17       	cp	r18, r24
 118:	39 07       	cpc	r19, r25
 11a:	e4 f2       	brlt	.-72     	; 0xd4 <selectionSort+0x10>
  
        // Swap the found minimum element 
        // with the first element 
        swap(&arr[min_idx], &arr[i]); 
    } 
} 
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	1f 91       	pop	r17
 122:	0f 91       	pop	r16
 124:	08 95       	ret

Disassembly of section .text.writearray:

00000184 <writearray>:
  
// Function to PORTD = sorted_array [i]; an array 
void writearray (uint8_t arr [], uint8_t size)
{ 
 184:	ac 01       	movw	r20, r24
    uint8_t i; 
    for (i = 0; i < size; i++) 
 186:	90 e0       	ldi	r25, 0x00	; 0
 188:	06 c0       	rjmp	.+12     	; 0x196 <writearray+0x12>
    PORTD = arr[i]; 
 18a:	fa 01       	movw	r30, r20
 18c:	e9 0f       	add	r30, r25
 18e:	f1 1d       	adc	r31, r1
 190:	20 81       	ld	r18, Z
 192:	2b b9       	out	0x0b, r18	; 11
  
// Function to PORTD = sorted_array [i]; an array 
void writearray (uint8_t arr [], uint8_t size)
{ 
    uint8_t i; 
    for (i = 0; i < size; i++) 
 194:	9f 5f       	subi	r25, 0xFF	; 255
 196:	96 17       	cp	r25, r22
 198:	c0 f3       	brcs	.-16     	; 0x18a <writearray+0x6>
    PORTD = arr[i]; 
} 
 19a:	08 95       	ret

Disassembly of section .text.main:

00000126 <main>:
  
// Driver code 
int main() 
{ 
 126:	cf 93       	push	r28
 128:	df 93       	push	r29
 12a:	cd b7       	in	r28, 0x3d	; 61
 12c:	de b7       	in	r29, 0x3e	; 62
 12e:	2a 97       	sbiw	r28, 0x0a	; 10
 130:	0f b6       	in	r0, 0x3f	; 63
 132:	f8 94       	cli
 134:	de bf       	out	0x3e, r29	; 62
 136:	0f be       	out	0x3f, r0	; 63
 138:	cd bf       	out	0x3d, r28	; 61
    DDRD = 0b11111111;
 13a:	8f ef       	ldi	r24, 0xFF	; 255
 13c:	8a b9       	out	0x0a, r24	; 10
    uint8_t arr[] = {100, 40, 20, 50, 30, 60, 80, 70, 10, 90 }; 
 13e:	8a e0       	ldi	r24, 0x0A	; 10
 140:	e0 e0       	ldi	r30, 0x00	; 0
 142:	f1 e0       	ldi	r31, 0x01	; 1
 144:	de 01       	movw	r26, r28
 146:	11 96       	adiw	r26, 0x01	; 1
 148:	01 90       	ld	r0, Z+
 14a:	0d 92       	st	X+, r0
 14c:	8a 95       	dec	r24
 14e:	e1 f7       	brne	.-8      	; 0x148 <main+0x22>
    uint8_t n = sizeof(arr) / sizeof(arr[0]); 
    writearray(arr,n);
 150:	6a e0       	ldi	r22, 0x0A	; 10
 152:	ce 01       	movw	r24, r28
 154:	01 96       	adiw	r24, 0x01	; 1
 156:	0e 94 c2 00 	call	0x184	; 0x184 <writearray>
  
    selectionSort(arr, n); 
 15a:	6a e0       	ldi	r22, 0x0A	; 10
 15c:	ce 01       	movw	r24, r28
 15e:	01 96       	adiw	r24, 0x01	; 1
 160:	0e 94 62 00 	call	0xc4	; 0xc4 <__data_load_end>
    writearray(arr,n);
 164:	6a e0       	ldi	r22, 0x0A	; 10
 166:	ce 01       	movw	r24, r28
 168:	01 96       	adiw	r24, 0x01	; 1
 16a:	0e 94 c2 00 	call	0x184	; 0x184 <writearray>
  
    return 0; 
 16e:	80 e0       	ldi	r24, 0x00	; 0
 170:	90 e0       	ldi	r25, 0x00	; 0
 172:	2a 96       	adiw	r28, 0x0a	; 10
 174:	0f b6       	in	r0, 0x3f	; 63
 176:	f8 94       	cli
 178:	de bf       	out	0x3e, r29	; 62
 17a:	0f be       	out	0x3f, r0	; 63
 17c:	cd bf       	out	0x3d, r28	; 61
 17e:	df 91       	pop	r29
 180:	cf 91       	pop	r28
 182:	08 95       	ret

Disassembly of section .text.__dummy_fini:

000001cc <_fini>:
 1cc:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

000001ce <__funcs_on_exit>:
 1ce:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

000001d0 <__simulator_exit>:
 1d0:	08 95       	ret

Disassembly of section .text.exit:

0000019c <exit>:
 19c:	ec 01       	movw	r28, r24
 19e:	0e 94 e7 00 	call	0x1ce	; 0x1ce <__funcs_on_exit>
 1a2:	0e 94 e6 00 	call	0x1cc	; 0x1cc <_fini>
 1a6:	ce 01       	movw	r24, r28
 1a8:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <__simulator_exit>
 1ac:	ce 01       	movw	r24, r28
 1ae:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <_Exit>

Disassembly of section .text._Exit:

000001c8 <_Exit>:
 1c8:	0e 94 60 00 	call	0xc0	; 0xc0 <_exit>
